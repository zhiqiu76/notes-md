#### 事务

- 定义及特性  一致性，隔离性，原子性，持久性

> 事物官方解释就是: 数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成, 通俗理解就是要么不做要么全做完, 也就是说它是一个不可分割的总体. 这就有点类似于我们化学里面所学到的原子, 它是构成物质的基本单位. 因此人们就归纳出事物的第一个特性: 原子性（Atomicity）。 

> 事物在数据库中占有很重要的地位, 所以它除了原子性还有一个极其重要的特性一致性（Consistency）.也就是说，执行完数据库操作后，数据不会被破坏。打个比方，如果从 A 账户转账到 B 账户，不可能因为 A 账户扣了钱，而 B 账户没有加钱吧。如果出现了这类事情，大家一定会非常气愤！

> 当我们编写了一条 update 语句，提交到数据库的一刹那间，有可能别人也提交了一条 delete 语句到数据库中。也许我们都是对同一条记录进行操作，可以想象，如果不稍加控制，就会出大麻烦来。我们必须保证数据库操作之间是“隔离”的（线程之间有时也要做到隔离），彼此之间没有任何干扰。这就是：隔离性（Isolation）。要想真正的做到操作之间完全没有任何干扰是很难的，于是每天上班打酱油的数据
> 库专家们，开始动脑筋了，“我们要制定一个规范，让各个数据库厂商都支持我们的规范！”，这个规范就是：事务隔离级别（Transaction Isolation Level）

> 能定义出这样牛逼的规
> 范真的挺不容易的，其实就四个级别： 

1. READ_UNCOMMITTED 
 2. READ_COMMITTED 
 3. REPEATABLE_READ 
 4. SERIALIZABLE 

千万不要去翻译，那只是一个代号而已。从上往下，级别越来越高，并发性越来越差，安全性越来越高，反之则反。不同的数据库之间默认隔离级别不一致。 

> 当我们执行一条 insert 语句后，数据库必须要保证有一条数据永久地存放在磁盘中，这个也算事务的一条特性， 它就是：持久性（Durability）。 

> 归纳一下，以上一共提到了事务的 4 条特性，把它们的英文单词首字母合起来就是：ACID，这个就是传说中的“事务 ACID 特性”！ 

==其实：原子性是基础，隔离性是手段，持久性是目的，真正的老大就是一致性。数据不一致了，其他都不用谈了。所以说，这三个小弟都是跟着“一致性”这个老大混，为他全心全意服务。==

>  这四个家伙当中，其实最难理解的反倒不是一致性，而是隔离性。因为它是保证一致性的重要手段，是工具，使用它不能有半点差池，否则后果很严重！因此就出来事务隔离级别了。其实，定义这四个级别就是为了解决数据在高并发下所产生的问题，那又有哪些问题呢？ 

1. Dirty Read（脏读） 2. Unrepeatable Read（不可重复读） 3. Phantom Read（幻读） 

事务隔离级别                                   脏读                       不可重复读                         幻读 
READ_UNCOMMITTED                  允许                           允许                                 允许 
READ_COMMITTED                        禁止                          允许                                  允许 
REPEATABLE_READ                        禁止                           禁止                                 允许 
SERIALIZABLE                                 禁止                           禁止                                 禁止 

##### MySQL 事务的命令

- InnDB 引擎

> 该存储引擎为 MySQL 表提供了 ACID 事务支持、系统崩溃修复能力和多版本并发控制（即 MVCC Multi-Version Concurrency Control）的行级锁;该引擎支持自增长列（auto_increment）,自增长列的值不能为空，如果在使用的时候为空则自动从现有值开始增值，如果有但是比现在的还大，则直接保存这个值; 该引擎存储引擎支持外键（foreign key） ,外键所在的表称为子表而所依赖的表称为父表。该引擎在 5.5 后的 MySQL 数据库中为默认存储引擎。

只有 inndb 才支持事务。

MySQL 默认的事务隔离级别为 REPEATABLE_READ。 

==如果手动开启事务，需要手动commit 否则之前的操作都没有用==

```mysql
begin                                         -- 手动开启事务
insert into user values ('stefan','password') -- 数据在缓冲区  还没有写入磁盘
commint                                       -- 提交  把缓冲区的数据写入磁盘  插入了一个记录



begin
insert into user values ('stefan','password') -- 数据在缓冲区  还没有写入磁盘
rollback                                      -- 数据回退 清空了缓冲区
commit                                        -- 提交 ，因为之前回退了 所以最后没有对表更改


begin
insert into user values ('stefan','password') -- 数据在缓冲区  还没有写入磁盘
savepoint point_1                             -- 设置保存节点 
insert into user values ('damon','password')  -- 数据在缓冲区  还没有写入磁盘
ROLLBACK TO point_1                           -- 回退至 这个节点前
commint                                       -- 最后提交 插入一了 stefan 

```

- ISAM 

>  该引擎在读取数据方面速度很快，而且不占用大量的内存和存储资源；但是 ISAM 不支持事务处理、不支持外来键、不能够容错、也不支持索引。该引擎在包括 MySQL 5.1及其以上版本的数据库中不再支持。 

- MyISAM

> 该引擎基于 ISAM 数据库引擎，除了提供 ISAM 里所没有的索引和字段管理等大量功能，MyISAM 还使用一种表格锁定的机制来优化多个并发的读写操作，但是需要经常运行OPTIMIZE TABLE 命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。MyISAM 还有一些有用的扩展，例如用来修复数据库文件的 MyISAMChk 工作

> MyISAM 强调了快速读取操作，主要用于高负载的select

- MyISAM 与 InnoDB 的区别（面试)

两种类型最主要的差别就是 Innodb 支持事务处理与外键和行级锁，MyISAM 的查询速度会比 InnoDB 快。 